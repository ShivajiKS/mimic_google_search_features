If the parent component is re-rendered then child components also re-rendered. But if the child component is re-rendered, the parent component is not re-rendered.

Key points:

1. If re-render happens, the state variables and useEffect with empty dependence are not going to re-rendered.

2. Normal variables and functions are re-declared.

3. useEffect are executed in sequence order :
4. useEffect with empty dependence array and useEffect without array dependence : first useffect willl be executed.

5. useEffect without dependence array and useEffect with empty array dependence : first useffect willl be executed.

6. useEffects are executed after jxs rendered (loads).

7. Don't put any data fetching logic within useEffect without any dependence array, it is also a performance issue.

Q1. If some code should be executed before jxs loads.
Ans : you can directly write within the component.

Usecases of [] :

1. dynamic object keys.
2. Multi object keys.

Boolean(52)

Boolean("52")

Boolean(true)

Boolean(function a(){}

all of These values are truthy values and will evaluate to true in a Boolean context so if we put any of these values in this part of if condition, then it would be treated as a true and execute the if block but which values would evaluate to false, which values are false

There are only 8 falsy value in JavaScript.

history time, If we rewind a few years, It was common for web frameworks to specialize in either server side rendering, static site generation, client side rendering, backend api endpoints. This created an all or nor decision, Where your whole application had to follow a single paradigm even when it wasn't optimal for some routes.

As user expectations and industry trends involved, developer started to experience friction with single paradigm frameworks.

some cases :
Dynamic heavy apps wanted to statically render some page ahead of time.

Static sites wanted to add some personalization.

Server first apps wanted to some client side interactivity and routing.

Client rendered app wanted to improve the initial load performance and seo of some pages or serve some backend api routes.

Next.js grew in popularity because it offered more rendering diversity. Teams could use the some tool, in the same language and routing system and component model to handle the different usecases of all their routes without having to manage handoffs between different systems
so what does this all have to do with partially pre rendering.
Fast forward to today, and once again, we're starting to reach the limit of single rendering paradigm.

This time at the more granular page level. Even the most static pages like documentation page or blog pages sometimes need dynamic elements such as personalized code snippets or a global navbar with the signed-in user and even the most dynamic pages share huge portion of static content between users but you've probably already noticed the logical limitation with pre rendering pages. We can't pre render a page that depends on runtime information before receiving the request that contains that information.

This leaves us with another all or nothing decision: either we statically pre render the page and lose the ability to personalize any of it. Or we dynamically render the entire page on every request. This is where partial pre rendering comes in. It allows us to combine the benefits and abilities of pre rendering and dynamic rendering on the same page. Making page as static or as dynamic as they need to be.

So how dies it works?
As a reminder, next.js currently pre renders a page at build time unless it uses dynamic apis like incoming request headers or uncached data requests.
Header()
Cookies ()
Nostore()
Fetch(url, {cache:"no-store"})

These api signal the developer's intention and opt the whole page into dynamic rendering at runtime. This means using a single dynamic function opts all its parent components up to the root into dynamic rendering even if those components don't contains any other references to runtime information.

What if we could somehow isolate this side effect and prevent it from spreading upwards.
React has a concept of boundaries. Boundaries allow us to design a system that accounts for two opposing modes.
For example, A page can be in a functioning or non functioning state
We can wrap thr part of the page in a react error boundary and Design fallback ui for potential non functioning state, if the wrapped ui ever enters this state, the error boundary will catch the error and render the user friendly fallback ui. This prevents the erroneous behaviour inside an error boundary from breaking the rest of the page.
similarly we can wrap components that includes asynchronous operations in react suspens boundary and fallback ui for temporary loading states.
When rendering on the server, react will immediately stream the fallback ui to the client and eventually, the actual wrapped components once their async dependence resolve. This prevents async operation inside a suspense boundary from blocking the rendering of the rest of the page.

Partial pre rendering extends the use of react suspense boundary. In addition to async code , we can now also wrap the component that use runtime dynamic apis in a suspense boundary and fallback ui for static pre rendered state.
This mechanism prevents dynamic apis inside the suspense boundary from opting the rest of the page into dynamic rendering.

Since dynamic rendering can now be isolated to ui inside suspense boundary, react can statically pre render as much of the page as possible at build time while postponing the rendering of ui inside suspense boundaries until runtime.

When your app is deployed, the partially prerendering results will be pushed to edge network and globally distributed.
Until u change, u can't change your future.
Only you can change your life.

Live and grow like a grass because life is a gift to you.

If you live a life, you should remember it for ages and realise that it was a best one.

If you keep live in past, you lose yourself in present and If you lose yourself in present,you will have no future.

As you level up, your difficult level increase and happiness decrease too.

Everyone has own timeline.

At runtime, when a user visits the page, edge compute close to the user will immediately server the static pre-rendered results. Simultaneously, it will also initiate a request to a runtime server to start rendering the dynamic parts.

On client side, the browser can start essential work like painting the pre rendering html to the screen, downloading static assist such images, fonts, style sheets and the javascript bundle that includes the React and Next.js runtime and even making downloaded client component interactive. At the same time, the server uses runtime information such as incoming requests and headers, cookies and to fetch data, render and stream the chunks to the client as soon as they become ready.
Finally, back on the client , the browser files in the dynamic holes as they stream in by replacing the prerendering fallback ui with fresh dynamic content
[2/4, 3:17 PM] Eswari: 1. Calculate number of records.

2. Ignore the previous records.

First : (pageNumber -1 )* page size
0*6 = 0 // skip the first 0 records.
Second : (2-1)*6 = 6 records skipped.
Third : (3-1) *6 = 12 records skipped.

Data.find({}). limit(page size).skip(inject the above formula)

3. Calculate number of pages : math.ceil(total records / page size)

4. Pass the total page as prop to pagination component.

5. Pass the current page as prop to pagination component for Highlight the current page.
   [2/4, 3:28 PM] Eswari: 6.Previous and Next buttons :

Previous button : <Link href={`/?page=${current page -1}`} />

Next button : <Link href={`/page=${current page + 1}`} />

Edge cases :

1. No need to display previous button for first page.

2. No need to display Next button for last page.
   [2/4, 6:43 PM] Eswari: Create a page variable :
3. Assign the page value from props to variable, but you can also initialize the default value 1
   Const page = props.page || 1
   Or you can use ternary operator.

Properly Handle the errors because if the page value is higher than current limit value..

import SearchBox from "@/components/HomeSearch";
import Link from "next/link";

export default function Home() {
return (
<main className="min-h-screen w-screen flex flex-col pt-40 bg-zinc-00 ">
<div className="flex justify-center items-center pb-12">
<Link href={"/"}>
<img
            src="vs-search-engine-high-resolution-logo-transparent.png"
            alt="google image..."
            className="h-14 lg:h-20"
          />
</Link>
</div>
<div>
<SearchBox />
</div>
</main>
);
}
